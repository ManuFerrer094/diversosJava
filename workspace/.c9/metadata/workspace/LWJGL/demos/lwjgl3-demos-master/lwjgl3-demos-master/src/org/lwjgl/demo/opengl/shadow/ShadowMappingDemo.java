{"changed":false,"filter":false,"title":"ShadowMappingDemo.java","tooltip":"/LWJGL/demos/lwjgl3-demos-master/lwjgl3-demos-master/src/org/lwjgl/demo/opengl/shadow/ShadowMappingDemo.java","value":"/*\n * Copyright LWJGL. All rights reserved.\n * License terms: http://lwjgl.org/license.php\n */\npackage org.lwjgl.demo.opengl.shadow;\n\nimport static org.lwjgl.demo.opengl.util.DemoUtils.*;\nimport static org.lwjgl.glfw.GLFW.*;\nimport static org.lwjgl.opengl.GL11.*;\nimport static org.lwjgl.opengl.GL12.*;\nimport static org.lwjgl.opengl.GL15.*;\nimport static org.lwjgl.opengl.GL20.*;\nimport static org.lwjgl.opengl.GL30.*;\nimport static org.lwjgl.system.MemoryUtil.NULL;\nimport static org.lwjgl.system.MemoryUtil.memAddress;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.nio.FloatBuffer;\nimport java.nio.IntBuffer;\n\nimport org.lwjgl.BufferUtils;\nimport org.lwjgl.PointerBuffer;\nimport org.lwjgl.demo.opengl.raytracing.Scene;\nimport org.lwjgl.demo.opengl.util.DemoUtils;\nimport org.lwjgl.glfw.GLFWErrorCallback;\nimport org.lwjgl.glfw.GLFWFramebufferSizeCallback;\nimport org.lwjgl.glfw.GLFWKeyCallback;\nimport org.lwjgl.glfw.GLFWVidMode;\nimport org.lwjgl.opengl.GL;\nimport org.lwjgl.opengl.GLCapabilities;\nimport org.lwjgl.opengl.GLUtil;\nimport org.lwjgl.system.Callback;\nimport org.joml.Matrix4f;\nimport org.joml.Vector3f;\n\n/**\n * Simple demo to showcase shadow mapping with a custom shader doing perspective\n * divide and depth test (i.e. no sampler2DShadow).\n * \n * @author Kai Burjack\n */\npublic class ShadowMappingDemo {\n\n\tprivate static Vector3f[] boxes = Scene.boxes2;\n\tprivate static Vector3f UP = new Vector3f(0.0f, 1.0f, 0.0f);\n\n\tstatic int shadowMapSize = 1024;\n\tstatic Vector3f lightPosition = new Vector3f(6.0f, 3.0f, 6.0f);\n\tstatic Vector3f lightLookAt = new Vector3f(0.0f, 1.0f, 0.0f);\n\tstatic Vector3f cameraPosition = new Vector3f(-3.0f, 6.0f, 6.0f);\n\tstatic Vector3f cameraLookAt = new Vector3f(0.0f, 0.0f, 0.0f);\n\tstatic float lightDistance = 10.0f;\n\tstatic float lightHeight = 4.0f;\n\n\tlong window;\n\tint width = 1200;\n\tint height = 800;\n\n\tint vao;\n\tint vbo;\n\tint shadowProgram;\n\tint shadowProgramVPUniform;\n\tint normalProgram;\n\tint normalProgramBiasUniform;\n\tint normalProgramVPUniform;\n\tint normalProgramLVPUniform;\n\tint normalProgramLightPosition;\n\tint normalProgramLightLookAt;\n\tint fbo;\n\tint depthTexture;\n\tint samplerLocation;\n\n\tFloatBuffer matrixBuffer = BufferUtils.createFloatBuffer(16);\n\n\tMatrix4f light = new Matrix4f();\n\tMatrix4f camera = new Matrix4f();\n\tMatrix4f biasMatrix = new Matrix4f(\n\t\t\t0.5f, 0.0f, 0.0f, 0.0f,\n\t\t\t0.0f, 0.5f, 0.0f, 0.0f,\n\t\t\t0.0f, 0.0f, 0.5f, 0.0f,\n\t\t\t0.5f, 0.5f, 0.5f, 1.0f\n\t\t\t);\n\n\tGLCapabilities caps;\n\tGLFWErrorCallback errCallback;\n\tGLFWKeyCallback keyCallback;\n\tGLFWFramebufferSizeCallback fbCallback;\n\tCallback debugProc;\n\n\tvoid init() throws IOException {\n\t\tglfwSetErrorCallback(errCallback = new GLFWErrorCallback() {\n\t\t\tGLFWErrorCallback delegate = GLFWErrorCallback.createPrint(System.err);\n\n\t\t\tpublic void invoke(int error, long description) {\n\t\t\t\tif (error == GLFW_VERSION_UNAVAILABLE)\n\t\t\t\t\tSystem.err.println(\"This demo requires OpenGL 3.0 or higher.\");\n\t\t\t\tdelegate.invoke(error, description);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void free() {\n\t\t\t\tdelegate.free();\n\t\t\t}\n\t\t});\n\n\t\tif (!glfwInit())\n\t\t\tthrow new IllegalStateException(\"Unable to initialize GLFW\");\n\n\t\tglfwDefaultWindowHints();\n\t\tglfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n\t\tglfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n\t\tglfwWindowHint(GLFW_VISIBLE, GLFW_FALSE);\n\t\tglfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE);\n\n\t\twindow = glfwCreateWindow(width, height, \"Shadow Mapping Demo\", NULL, NULL);\n\t\tif (window == NULL) {\n\t\t\tthrow new AssertionError(\"Failed to create the GLFW window\");\n\t\t}\n\n\t\tglfwSetKeyCallback(window, keyCallback = new GLFWKeyCallback() {\n\t\t\t@Override\n\t\t\tpublic void invoke(long window, int key, int scancode, int action, int mods) {\n\t\t\t\tif (action != GLFW_RELEASE)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (key == GLFW_KEY_ESCAPE) {\n\t\t\t\t\tglfwSetWindowShouldClose(window, true);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tglfwSetFramebufferSizeCallback(window, fbCallback = new GLFWFramebufferSizeCallback() {\n\t\t\tpublic void invoke(long window, int width, int height) {\n\t\t\t\tif (width > 0 && height > 0 && (ShadowMappingDemo.this.width != width || ShadowMappingDemo.this.height != height)) {\n\t\t\t\t\tShadowMappingDemo.this.width = width;\n\t\t\t\t\tShadowMappingDemo.this.height = height;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tGLFWVidMode vidmode = glfwGetVideoMode(glfwGetPrimaryMonitor());\n\t\tglfwSetWindowPos(window, (vidmode.width() - width) / 2, (vidmode.height() - height) / 2);\n\t\tglfwMakeContextCurrent(window);\n\t\tglfwSwapInterval(0);\n\t\tglfwShowWindow(window);\n\n\t\tIntBuffer framebufferSize = BufferUtils.createIntBuffer(2);\n\t\tnglfwGetFramebufferSize(window, memAddress(framebufferSize), memAddress(framebufferSize) + 4);\n\t\twidth = framebufferSize.get(0);\n\t\theight = framebufferSize.get(1);\n\n\t\tcaps = GL.createCapabilities();\n\t\tdebugProc = GLUtil.setupDebugMessageCallback();\n\n\t\t/* Set some GL states */\n\t\tglEnable(GL_CULL_FACE);\n\t\tglEnable(GL_DEPTH_TEST);\n\t\tglClearColor(0.2f, 0.3f, 0.4f, 1.0f);\n\n\t\t/* Create all needed GL resources */\n\t\tcreateVao();\n\t\tcreateShadowProgram();\n\t\tinitShadowProgram();\n\t\tcreateNormalProgram();\n\t\tinitNormalProgram();\n\t\tcreateDepthTexture();\n\t\tcreateFbo();\n\t}\n\n\t/**\n\t * Create the texture storing the depth values of the light-render.\n\t */\n\tvoid createDepthTexture() {\n\t\tdepthTexture = glGenTextures();\n\t\tglBindTexture(GL_TEXTURE_2D, depthTexture);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n\t\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n\t\tglTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, shadowMapSize, shadowMapSize, 0, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE,\n\t\t\t\t(ByteBuffer) null);\n\t\tglBindTexture(GL_TEXTURE_2D, 0);\n\t}\n\n\t/**\n\t * Create the FBO to render the depth values of the light-render into the\n\t * depth texture.\n\t */\n\tvoid createFbo() {\n\t\tfbo = glGenFramebuffers();\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, fbo);\n\t\tglBindTexture(GL_TEXTURE_2D, depthTexture);\n\t\tglDrawBuffer(GL_NONE);\n\t\tglReadBuffer(GL_NONE);\n\t\tglFramebufferTexture2D(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_TEXTURE_2D, depthTexture, 0);\n\t\tint fboStatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);\n\t\tif (fboStatus != GL_FRAMEBUFFER_COMPLETE) {\n\t\t\tthrow new AssertionError(\"Could not create FBO: \" + fboStatus);\n\t\t}\n\t\tglBindTexture(GL_TEXTURE_2D, 0);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\t}\n\n\t/**\n\t * Creates a VAO for the scene with some boxes.\n\t */\n\tvoid createVao() {\n\t\tvao = glGenVertexArrays();\n\t\tint vbo = glGenBuffers();\n\t\tglBindVertexArray(vao);\n\t\tglBindBuffer(GL_ARRAY_BUFFER, vbo);\n\t\tByteBuffer bb = BufferUtils.createByteBuffer(boxes.length * 4 * (3 + 3) * 6 * 6);\n\t\tFloatBuffer fv = bb.asFloatBuffer();\n\t\tfor (int i = 0; i < boxes.length; i += 2) {\n\t\t\tDemoUtils.triangulateBox(boxes[i], boxes[i + 1], fv);\n\t\t}\n\t\tglBufferData(GL_ARRAY_BUFFER, bb, GL_STATIC_DRAW);\n\t\tglEnableVertexAttribArray(0);\n\t\tglVertexAttribPointer(0, 3, GL_FLOAT, false, 4 * (3 + 3), 0L);\n\t\tglEnableVertexAttribArray(1);\n\t\tglVertexAttribPointer(1, 3, GL_FLOAT, false, 4 * (3 + 3), 4 * 3);\n\t\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n\t\tglBindVertexArray(0);\n\t}\n\n\tstatic int createShader(String resource, int type) throws IOException {\n\t\tint shader = glCreateShader(type);\n\n\t\tByteBuffer source = ioResourceToByteBuffer(resource, 8192);\n\n\t\tPointerBuffer strings = BufferUtils.createPointerBuffer(1);\n\t\tIntBuffer lengths = BufferUtils.createIntBuffer(1);\n\n\t\tstrings.put(0, source);\n\t\tlengths.put(0, source.remaining());\n\n\t\tglShaderSource(shader, strings, lengths);\n\t\tglCompileShader(shader);\n\t\tint compiled = glGetShaderi(shader, GL_COMPILE_STATUS);\n\t\tString shaderLog = glGetShaderInfoLog(shader);\n\t\tif (shaderLog != null && shaderLog.trim().length() > 0) {\n\t\t\tSystem.err.println(shaderLog);\n\t\t}\n\t\tif (compiled == 0) {\n\t\t\tthrow new AssertionError(\"Could not compile shader\");\n\t\t}\n\t\treturn shader;\n\t}\n\n\tvoid createShadowProgram() throws IOException {\n\t\tshadowProgram = glCreateProgram();\n\t\tint vshader = createShader(\"org/lwjgl/demo/opengl/shadow/shadowMapping-vs.glsl\", GL_VERTEX_SHADER);\n\t\tint fshader = createShader(\"org/lwjgl/demo/opengl/shadow/shadowMapping-fs.glsl\", GL_FRAGMENT_SHADER);\n\t\tglAttachShader(shadowProgram, vshader);\n\t\tglAttachShader(shadowProgram, fshader);\n\t\tglBindAttribLocation(shadowProgram, 0, \"position\");\n\t\tglLinkProgram(shadowProgram);\n\t\tint linked = glGetProgrami(shadowProgram, GL_LINK_STATUS);\n\t\tString programLog = glGetProgramInfoLog(shadowProgram);\n\t\tif (programLog != null && programLog.trim().length() > 0) {\n\t\t\tSystem.err.println(programLog);\n\t\t}\n\t\tif (linked == 0) {\n\t\t\tthrow new AssertionError(\"Could not link program\");\n\t\t}\n\t}\n\n\tvoid initShadowProgram() {\n\t\tglUseProgram(shadowProgram);\n\t\tshadowProgramVPUniform = glGetUniformLocation(shadowProgram, \"viewProjectionMatrix\");\n\t\tglUseProgram(0);\n\t}\n\n\tvoid createNormalProgram() throws IOException {\n\t\tnormalProgram = glCreateProgram();\n\t\tint vshader = createShader(\"org/lwjgl/demo/opengl/shadow/shadowMappingShade-vs.glsl\", GL_VERTEX_SHADER);\n\t\tint fshader = createShader(\"org/lwjgl/demo/opengl/shadow/shadowMappingShade-fs.glsl\", GL_FRAGMENT_SHADER);\n\t\tglAttachShader(normalProgram, vshader);\n\t\tglAttachShader(normalProgram, fshader);\n\t\tglBindAttribLocation(normalProgram, 0, \"position\");\n\t\tglBindAttribLocation(normalProgram, 1, \"normal\");\n\t\tglLinkProgram(normalProgram);\n\t\tint linked = glGetProgrami(normalProgram, GL_LINK_STATUS);\n\t\tString programLog = glGetProgramInfoLog(normalProgram);\n\t\tif (programLog != null && programLog.trim().length() > 0) {\n\t\t\tSystem.err.println(programLog);\n\t\t}\n\t\tif (linked == 0) {\n\t\t\tthrow new AssertionError(\"Could not link program\");\n\t\t}\n\t}\n\n\tvoid initNormalProgram() {\n\t\tglUseProgram(normalProgram);\n\t\tsamplerLocation = glGetUniformLocation(normalProgram, \"depthTexture\");\n\t\tnormalProgramBiasUniform = glGetUniformLocation(normalProgram, \"biasMatrix\");\n\t\tnormalProgramVPUniform = glGetUniformLocation(normalProgram, \"viewProjectionMatrix\");\n\t\tnormalProgramLVPUniform = glGetUniformLocation(normalProgram, \"lightViewProjectionMatrix\");\n\t\tnormalProgramLightPosition = glGetUniformLocation(normalProgram, \"lightPosition\");\n\t\tnormalProgramLightLookAt = glGetUniformLocation(normalProgram, \"lightLookAt\");\n\t\tglUniform1i(samplerLocation, 0);\n\t\tglUseProgram(0);\n\t}\n\n\t/**\n\t * Update the camera MVP matrix.\n\t */\n\tvoid update() {\n\t\t/* Update light */\n\t\tdouble alpha = System.currentTimeMillis() / 1000.0 * 0.5;\n\t\tfloat x = (float) Math.sin(alpha);\n\t\tfloat z = (float) Math.cos(alpha);\n\t\tlightPosition.set(lightDistance * x, 3 + (float) Math.sin(alpha), lightDistance * z);\n\t\tlight.setPerspective((float) Math.toRadians(45.0f), 1.0f, 0.1f, 60.0f)\n\t\t     .lookAt(lightPosition, lightLookAt, UP);\n\n\t\t/* Update camera */\n\t\tcamera.setPerspective((float) Math.toRadians(45.0f), (float) width / height, 0.1f, 30.0f)\n\t\t      .lookAt(cameraPosition, cameraLookAt, UP);\n\t}\n\n\t/**\n\t * Render the shadow map into a depth texture.\n\t */\n\tvoid renderShadowMap() {\n\t\tglUseProgram(shadowProgram);\n\n\t\t/* Set MVP matrix of the \"light camera\" */\n\t\tglUniformMatrix4fv(shadowProgramVPUniform, false, light.get(matrixBuffer));\n\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, fbo);\n\t\tglViewport(0, 0, shadowMapSize, shadowMapSize);\n\t\t/* Only clear depth buffer, since we don't have a color draw buffer */\n\t\tglClear(GL_DEPTH_BUFFER_BIT);\n\t\tglBindVertexArray(vao);\n\t\tglDrawArrays(GL_TRIANGLES, 0, 6 * 6 * boxes.length);\n\t\tglBindVertexArray(0);\n\t\tglBindFramebuffer(GL_FRAMEBUFFER, 0);\n\n\t\tglUseProgram(0);\n\t}\n\n\t/**\n\t * Render the scene normally, with sampling the previously rendered depth\n\t * texture.\n\t */\n\tvoid renderNormal() {\n\t\tglUseProgram(normalProgram);\n\n\t\t/* Set MVP matrix of camera */\n\t\tglUniformMatrix4fv(normalProgramVPUniform, false, camera.get(matrixBuffer));\n\t\t/* Set MVP matrix that was used when doing the light-render */\n\t\tglUniformMatrix4fv(normalProgramLVPUniform, false, light.get(matrixBuffer));\n\t\t/* The bias-matrix used to convert to NDC coordinates */\n\t\tglUniformMatrix4fv(normalProgramBiasUniform, false, biasMatrix.get(matrixBuffer));\n\t\t/* Light position and lookat for normal lambertian computation */\n\t\tglUniform3f(normalProgramLightPosition, lightPosition.x, lightPosition.y, lightPosition.z);\n\t\tglUniform3f(normalProgramLightLookAt, lightLookAt.x, lightLookAt.y, lightLookAt.z);\n\n\t\tglViewport(0, 0, width, height);\n\t\t/* Must clear both color and depth, since we are re-rendering the scene */\n\t\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\t\tglBindTexture(GL_TEXTURE_2D, depthTexture);\n\t\tglBindVertexArray(vao);\n\t\tglDrawArrays(GL_TRIANGLES, 0, 6 * 6 * boxes.length);\n\t\tglBindVertexArray(0);\n\t\tglBindTexture(GL_TEXTURE_2D, 0);\n\n\t\tglUseProgram(0);\n\t}\n\n\tvoid loop() {\n\t\twhile (!glfwWindowShouldClose(window)) {\n\t\t\tglfwPollEvents();\n\n\t\t\tupdate();\n\t\t\trenderShadowMap();\n\t\t\trenderNormal();\n\n\t\t\tglfwSwapBuffers(window);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tinit();\n\t\t\tloop();\n\n\t\t\tif (debugProc != null)\n\t\t\t\tdebugProc.free();\n\n\t\t\terrCallback.free();\n\t\t\tkeyCallback.free();\n\t\t\tfbCallback.free();\n\t\t\tglfwDestroyWindow(window);\n\t\t} catch (Throwable t) {\n\t\t\tt.printStackTrace();\n\t\t} finally {\n\t\t\tglfwTerminate();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew ShadowMappingDemo().run();\n\t}\n\n}","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":4740,"scrollleft":0,"selection":{"start":{"row":356,"column":12},"end":{"row":356,"column":12},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":344,"state":"doc-start","mode":"ace/mode/java"}},"timestamp":1521055041255}