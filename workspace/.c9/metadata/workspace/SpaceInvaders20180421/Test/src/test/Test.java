{"changed":false,"filter":false,"title":"Test.java","tooltip":"/SpaceInvaders20180421/Test/src/test/Test.java","value":"/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\npackage test;\n\nimport java.awt.Canvas;\nimport java.awt.Dimension;\nimport java.awt.Graphics2D;\nimport java.awt.event.*;\nimport java.awt.image.BufferStrategy;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\nimport javax.swing.*;\n\npublic class Test\n{\n    /*////////////////////////////////VARIABLES INICIALES///////////////////////////////////////////*/\n    Bucle bucle = new Bucle();\n    static JLabel label;\n    static final long FLIPDELAY = 500;\n    \n    \n    // Variables de Imagenes\n    static private BufferedImage imgJugador;\n    static private BufferedImage imgEnemigo;\n    static private BufferedImage imgFondo;\n    \n    //CONDICIONES INICIALES Declaracion de Variables\n    //Posicion del jugador \n    int miposx = 225;\n    int miposy = 450;\n    String movimientopersonaje = \"cucu\";\n    //Balas\n    int[] balaposx; //declaramos los array de las posiciones de las balas\n    int[] balaposy;\n    int balasmax = 0; // ponemos a 0 el contador de balas disparadas;\n    int balasmin = 0; //contador de balas dentro del terreno de juego\n    boolean[] balaviva; // variable bool para activar las balas\n    int balastiempo = 30; // contador de tiempo para el lanzamiento de balas\n\n    //Balas enemigos\n    static int[] balaenemigoposx; //declaramos los array de las posiciones de las balas\n    static int[] balaenemigoposy;\n    static int balaenemigomax = 0; // ponemos a 0 el contador de balas disparadas;\n    static int balaenemigomin = 0; //contador de balas dentro del terreno de juego\n    static boolean[] balaenemigoviva; // variable bool para activar las balas\n    int balasenemigotiempo = 0; // contador de tiempo para el lanzamiento de balas\n \n    //Enemigos\n    static public int[] enemigoposx; // almacenan la posicion x ,y de cada uno de los enemigos\n      \n    int enemigoposy = 25; // y común ya que se mueven en bloque\n    static int enemigos = 5; // número de enemigos con los que se inicia el nivel \n    int hasganado = (enemigos+1); // contador para saber cuando se han eliminado a todos los enemigos\n\n    static boolean[] enemigovivo; //almacena si el enemigo está vivo o no\n    String movimientoenemigos = \"derecha\";  // se inicia la variable de la direccion de movimiento usada en movimientoEnemigo()\n    static int WIDTH = 512;\n    static int HEIGHT = 512;\n    static BufferStrategy bufferStrategy;\n    \n  static JFrame frame;                                                               // Creacion de un marco sobre el que trabajar\n    static Canvas canvas;\n    \n    /*////////////////////////////////VARIABLES INICIALES///////////////////////////////////////////*/\n    \n    /*////////////////////////////////FUNCION DE INICIO///////////////////////////////////////////*/\n    public static void inicio(){\n         frame = new JFrame(\"Space Invaders\");                                   // Creamos una ventana\n        frame.setFocusable(true);\n        //frame.grabFocus();\n         frame.requestFocus();//or inWindow depends if Swing or Atw\n        // Creamos panel\n        JPanel panel = (JPanel) frame.getContentPane();                         // Creamos un nuevo panel dentro del marco\n        panel.setPreferredSize(new Dimension(WIDTH, HEIGHT));                   // Introducimos propiedades del panel\n        panel.setLayout(null);                                                  // Inicializamos el layout\n        panel.setFocusable(true);                                               // Permitimos que podamos hacer focus\n        \n        panel.requestFocusInWindow();\n        frame.addKeyListener(new KeyboardListener());\n        \n        \n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);                   // Cerrar el proceso al salir del programa\n        frame.pack();                                                           // Empaquetamos\n        frame.setResizable(false);                                              // No permitimos el reescalado\n        frame.setVisible(true);                                                 // Hacemos que sea visible\n        \n         frame.requestFocus();\n         canvas = new Canvas();  \n        canvas.createBufferStrategy(3);                                         // Creamos una estrategia de buffer\n        bufferStrategy = canvas.getBufferStrategy();                            // Asignamos al canvas\n        canvas.requestFocus();                                                  // Requerimos el foco del raton\n\n        //Adding the keylistener, just like adding any other kind of listener\n        frame.addKeyListener(new KeyboardListener());\n        \n        //Cargamos las imagenes\n        String imagePath = \"C:\\\\Users\\\\Vicente\\\\Desktop\\\\aver\\\\SpaceInvaders\\\\SpaceInvaders\\\\SpaceInvaders\\\\img\\\\\";\n        try {\n            imgJugador=ImageIO.read(new File(imagePath+\"jugador.png\"));\n            imgEnemigo=ImageIO.read(new File(imagePath+\"enemigo.png\"));\n            imgFondo=ImageIO.read(new File(imagePath+\"fondo_estrellado.jpg\"));\n        } catch (IOException e) {\n            // TODO Auto-generated catch block\n            e.printStackTrace();\n        }\n        \n        \n        //Inicializamos las variables y arrays\n        enemigoposx = new int[10]; \n        enemigoposx[0] = 25;\n        enemigoposx[1] = 75;\n        enemigoposx[2] = 125;\n        enemigoposx[3] = 175;\n        enemigoposx[4] = 225;\n        enemigoposx[5] = 275;\n\n        enemigovivo = new boolean[enemigos]; \n        for(int i=0; i<=(enemigos-1); i++){ //inicializa todos en true\n           \n            enemigovivo[i] = true;\n        }\n        // Inicializaciones\n        balaenemigoviva = new boolean[1000];\n        balaenemigoposx = new int[1000];\n        balaenemigoposy = new int[1000];\n        //enemigovivo = new boolean[enemigos];\n    }\n    /*////////////////////////////////FUNCION DE INICIO///////////////////////////////////////////*/\n\n    /*////////////////////////////////FUNCION MAIN///////////////////////////////////////////*/\n    public static void main(String... args) {\n        inicio();\n\n    }\n    /*////////////////////////////////FUNCION MAIN///////////////////////////////////////////*/\n    /*////////////////////////////////FUNCION ESCUCHADOR DE TECLAS///////////////////////////////////////////*/\n    private static class KeyboardListener implements KeyListener {\n        //Methods that dictates what should happen when you press a key\n        @Override \n        public void keyPressed(KeyEvent e) { \n            System.out.println(\"tecla pulsada\");\n        }\n        @Override public void keyReleased(KeyEvent e) {}\n        @Override public void keyTyped(KeyEvent e) {}\n    }\n    /*////////////////////////////////FUNCION ESCUCHADOR DE TECLAS///////////////////////////////////////////*/\n    /*////////////////////////////////FUNCION BUCLE///////////////////////////////////////////*/\n    private class Bucle implements Runnable {\n        boolean stopped = false;\n        int number = 0;\n\n        //this is the method that's executed when we call the start()-method on our thread\n        long desiredFPS = 100;                                                      // Especificamos los fps\n    long desiredDeltaLoop = (1000*1000*1000)/desiredFPS;                        // Calculamos los milisegundos de tasa de refresco\n    boolean running = true;                                                     // Variable para comprobar si esta en funcionamiento\n        public void run() {\n           \n             long beginLoopTime;\n        long endLoopTime;\n        long currentUpdateTime = System.nanoTime();\n        long lastUpdateTime;\n        long deltaLoop;\n        \n        while(running){                                                         // Mientras sea cierto que se esta ejecutando\n            beginLoopTime = System.nanoTime();                                  // Asigna el nano tiempo del sistema\n            render();                                                           // Llamada el metodo de render\n           \n           \n           \n            \n            lastUpdateTime = currentUpdateTime;                                 // Actualizacion de la variable\n            currentUpdateTime = System.nanoTime();                              // Asignación de un nuevo tiempo\n            update((int) ((currentUpdateTime - lastUpdateTime)/(1000*1000)));   // Llamada al metodo de actualizacion\n\n            endLoopTime = System.nanoTime();\n            deltaLoop = endLoopTime - beginLoopTime;\n           \n            if(deltaLoop > desiredDeltaLoop) {                                  // Si lo que has tardado en computar es mayor que los FPS\n                //System.out.println(\"No llego\");\n            }else {\n                try{\n                    Thread.sleep((desiredDeltaLoop - deltaLoop)/(1000*1000));   // Para la ejecicion (como el SetTimeout)\n                }catch(InterruptedException e){\n                   //Do nothing\n                }\n            }\n          \n        }\n        }\n        public void stop() {\n            stopped = true;\n        }\n    }\n    /*////////////////////////////////FUNCION BUCLE///////////////////////////////////////////*/\n    /*////////////////////////////////FUNCION ESPECIFICAS DEL JUEGO///////////////////////////////////////////*/\n    //Funcion de RENDER\n    private void render() {\n       \n        Graphics2D g = (Graphics2D) bufferStrategy.getDrawGraphics();           // Crea un nuevo grafico 2D\n        g.clearRect(0, 0, WIDTH, HEIGHT);                                       // Borra el grafico\n        render(g);                                                              // Llamada al metodo protegido render\n        g.dispose();                                                            // Vacia la memoria\n        bufferStrategy.show();                                                  // Muestra el buffer\n\n       // System.out.println(\"Entro en render\");\n    }\n    \n    \n    //Funcion de ACTUALIZACION\n    private double x = 0;                                                       // Creamos una variable para el desplazamiento de las cajas\n    protected void update(int deltaTime){                                       // Funcion para actualizar la posicion de las cajas\n        x += deltaTime * 0.2;                                                   // Avance en x\n        while(x > 500){                                                         // Siempre que la x sea mayor que 500\n            x -= 500;                                                           // Reinicia la x\n        }\n    }\n    \n    \n    //Funcion RENDER GRAPHICS\n    protected void render(Graphics2D g){                                        // Metodo que realmente dibuja\n        //Dibujar Fondo de Pantalla        \n        \n        \n        //System.out.println(\"Entro en render(graphics2d g)\");\n        \n        hasPerdido();\n\tmovimientoEnemigo();\n\tgestionBalas(); \n\tbalasAliens();\n\tmatarAlien();\n        //System.out.println(\"El movimiento personaje es: \"+movimientopersonaje);\n\tmovimientoJugador(); // funcion para dibjugar el movimiento del jugador dentro de los límites\n        g.drawImage(imgFondo, 0,0, null);\n        g.drawImage(imgJugador, miposx, miposy, null);\n        balastiempo++; // aumenta el contador de tiempo para el próximo lanzamiento\n\tbalasenemigotiempo++; // aumenta el contador de tiempo para el próximo lanzamiento\n    }\n    //MOVIMIENTO DEL JUGADOR\n    public void movimientoJugador(){\n            if(movimientopersonaje.equals(\"derecha\")){\n                miposx += 3;\n            }\n            if(movimientopersonaje.equals(\"izquierda\")){\n                miposx -= 3;\n            }\n            //Controlar limites de movimiento\n            if(miposx > WIDTH-10){\n                miposx = WIDTH-10;\n            }\n            if(miposx < 10){\n                miposx = 10;\n            }\n            \n            //Dibuja la imagen del jugador\n            \n    }\n\n    //Balas Jugador\n    public void gestionBalas(){\n        //Comprobamos todas las balas creadas\n        for(int i = balasmin; i<balasmax; i++){\n            balaposy[i] -= 3;\n\n            //Dibujamos las balas si estan dentro del canvas\n            if(balaposy[i] > 0) {  \n                if(balaviva[i]){\n                    //DIBUJAR BALA\n                    //g.setColor(Color.WHITE); \n                    //g.fillRect(balaposx[i], balaposy[i], 2, 2);\n                }\n            }else {\n                balasmin++; // si no entra dentro del contenedor, no se vuelve a intentar dibujar ya que su posicion sera menor a 0\n            }\n        }\n    }\n\n    //Balas Enemigas\n    public void balasAliens(){\n         \n        if(balasenemigotiempo == 35){\n            int random = (int)Math.floor(Math.random()*(enemigos));           // Selecciona un enemigo al azar\n            balasenemigotiempo = 0;                                             // Reinicia contador de tiempo de balas\n            if(enemigovivo[random]){\n                // Activa la bala y le damos posicion\n                balaenemigoviva[balaenemigomax] = true;\n                balaenemigoposx[balaenemigomax] = enemigoposx[random];\n                balaenemigoposy[balaenemigomax] = enemigoposy + 50;\n                balaenemigomax++;                                               // Aumenta en uno el contador de balas \n            }\n        }\n        for(int i=balaenemigomin; i<balaenemigomax; i++) {\n            balaenemigoposy[i] += 3;\n            if(balaenemigoposy[i]<470){\n                if(balaenemigoviva[i]){\n                    //g.setColor(Color.GREEN); \n                    //g.fillRect(balaenemigoposx[i], balaenemigoposy[i], 2, 2);\n                } else {\n                    balasmin++;\n                }\n            }\n        }\n    }\n    \n    //Movimiento Enemigo\n    public void movimientoEnemigo(){\n        //$(\"#enemigos\").html(\"\"); // limpia el html\n\n        //Si los enemigos llegan a la izquierda cambian de direccion y bajan una linea\n        if(enemigoposx[0] <= 10) {\n            movimientoenemigos = \"derecha\";\n            enemigoposy += 45;\n        }\n        //Si los enemigos llegan a la derecha cambian de direccion y bajan una linea\n        if(enemigoposx[enemigos] >= 440) {\n            movimientoenemigos = \"izquierda\";\n            enemigoposy += 45;\n        }\n\n        if(movimientoenemigos.equals(\"derecha\")){                                // Mueve todos los aliens a la derecha\n            for(int i=0; i<=enemigos; i++){\n                enemigoposx[i]+=3;\n            }\n        }\n        if(movimientoenemigos.equals(\"izquierda\")){                              // Mueve todos los aliens a la izquierda\n            for(int i = 0;i <= enemigos;i++){\n                enemigoposx[i]-=3;\n            }\n        }\n        //Dibujamos a los enemigos\n        for(int i=0; i<=enemigos-1; i++){\n            if(enemigovivo[i]){\n                //g.drawImage(imgEnemigo, enemigoposx[i], enemigoposy, null);\n            }\n        }\n    }\n\n    //Alien toca al jugador\n    public void hasPerdido(){\n        // Si el enemigo me pasa o me toca, muero\n        for(int i=0; i<=enemigos-1; i++){\n            if(enemigovivo[i]) {\n                if(enemigoposy >= miposy){\n                    enemigovivo[i] = false;\n                    // Has perdido\n                   // System.out.println(\"HAS PERDIDO\");\n                }\n                // Si el enemigo choca conmigo muero\n                if(Math.abs(enemigoposx[i]-(miposx+25)) < 25 && Math.abs(enemigoposy-miposy) < 25) {\n                    enemigovivo[i] = false;\n                    //Has perdido\n                    //System.out.println(\"HAS PERDIDO\");\n                }\n            }\n        }\n        // Si la bala disparada por el enemigo choca conmigo, muero\n        for(int i=balaenemigomin; i<balaenemigomax; i++) {\n            if(Math.abs((balaenemigoposx[i]+2)-(miposx+22))<25 && Math.abs((miposy+22)-(balaenemigoposy[i]+10))<25){\n                if(balaenemigoviva[i]){\n                    //System.out.println(\"HAS PERDIDO\");\n                    //Has perdido\n                }\n            }\n        }\n    }\n\n    //Matar un Alien\n    public void matarAlien(){\n        for(int i=balasmin; i<balasmax; i++){                                   // Recorre todas las balas disparadas activas\n            for(int j=0; j<=enemigos; j++){                                     // Recorre todos los enemigos\n                if(Math.abs(balaposx[i]-(enemigoposx[j]+22))<25 && Math.abs((enemigoposy+22)-balaposy[i])<25){\n                    // Si la bala choca con un enemigo y ambos estan activos...\n                    if(enemigovivo[j] && balaviva[i]){\n                        enemigovivo[j] = false;                                 // Muere el enemigo\n                        balaviva[i] = false;                                    // muere la bala\n                        hasganado--;                                            // resta uno al contador para saber si estan todos muertos\n                        if(hasganado == 0){\n                            //System.out.println(\"HAS GANADO\");\n                            //alert(\"Has ganado\");                                // si todos han muerto he ganado\n                        }\n                    } else {\n                        //console.log(\"El enemigo ya estaba muerto\");\n                        //System.out.println(\"El enemigo ya estaba muerto\");\n                    }\n                }\n            }\n        }\n    }\n    /*////////////////////////////////FUNCION BUCLE///////////////////////////////////////////*/\n}\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":970,"scrollleft":0,"selection":{"start":{"row":77,"column":32},"end":{"row":77,"column":32},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":65,"state":"start","mode":"ace/mode/java"}},"timestamp":1524404641528}